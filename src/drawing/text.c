#include "text.h"

#include <obs.h>
#include <obs-module.h>
#include <graphics/graphics.h>

// `src/sources/glyph_atlas_text_source.c`
//
// struct glyph {
//     char ch;
//     int  x, y, w, h; // atlas pixel rect
//     int  xoff, yoff; // bearing offsets
//     int  xadv;       // advance
// };
//
// struct atlas_text_source {
//     obs_source_t *source;
//     gs_texture_t *atlas;
//     gs_effect_t  *effect;
//
//     uint32_t color; // 0xAARRGGBB tint (optional)
//     char    *text;
//
//     int atlas_w, atlas_h;
//     int line_h;
//
//     // For a real implementation, store a map from char->glyph.
//     struct glyph glyphs[128];
//     size_t       glyph_count;
// };
//
// static const char *atlas_text_get_name(void *unused) {
//     (void)unused;
//     return "Atlas Text (custom)";
// }
//
// static void atlas_text_destroy(void *data) {
//     struct atlas_text_source *ctx = data;
//     if (!ctx)
//         return;
//
//     if (ctx->atlas)
//         gs_texture_destroy(ctx->atlas);
//     if (ctx->effect)
//         gs_effect_destroy(ctx->effect);
//     bfree(ctx->text);
//     bfree(ctx);
// }
//
// static void *atlas_text_create(obs_data_t *settings, obs_source_t *source) {
//     struct atlas_text_source *ctx = bzalloc(sizeof(*ctx));
//     ctx->source                   = source;
//
//     ctx->color = (uint32_t)obs_data_get_int(settings, "color");
//     if (!ctx->color)
//         ctx->color = 0xFFFFFFFF;
//
//     const char *t = obs_data_get_string(settings, "text");
//     ctx->text     = bstrdup(t ? t : "");
//
//     // Load an RGBA atlas image shipped with the plugin (prebaked glyphs).
//     // OBS provides helpers for module files; loading the image into a texture
//     // is usually done via gs_image_file_t.
//     gs_image_file_t img;
//     gs_image_file_init(&img, obs_module_file("glyph_atlas.png"));
//     gs_image_file_init_texture(&img);
//     if (img.loaded) {
//         ctx->atlas   = img.texture;
//         ctx->atlas_w = (int)img.cx;
//         ctx->atlas_h = (int)img.cy;
//     } else {
//         gs_image_file_free(&img);
//     }
//
//     // Simple effect that samples `image` and multiplies by `tint`.
//     ctx->effect = gs_effect_create_from_file(obs_module_file("atlas_text.effect"), NULL);
//
//     // TODO: load glyph metrics (x,y,w,h,xoff,yoff,xadv,line_h) from a small data file.
//     // For example: `glyph_atlas.json` generated by a Python script.
//
//     gs_image_file_free(&img);
//     ctx->line_h = 64; // placeholder
//     return ctx;
// }
//
// static void atlas_text_update(void *data, obs_data_t *settings) {
//     struct atlas_text_source *ctx = data;
//     if (!ctx)
//         return;
//
//     ctx->color = (uint32_t)obs_data_get_int(settings, "color");
//
//     const char *t = obs_data_get_string(settings, "text");
//     bfree(ctx->text);
//     ctx->text = bstrdup(t ? t : "");
// }
//
// static uint32_t atlas_text_get_width(void *data) {
//     struct atlas_text_source *ctx = data;
//     if (!ctx || !ctx->text)
//         return 0;
//
//     // Minimal: assume fixed advance for now.
//     size_t n = strlen(ctx->text);
//     return (uint32_t)(n * 32);
// }
//
// static uint32_t atlas_text_get_height(void *data) {
//     struct atlas_text_source *ctx = data;
//     if (!ctx)
//         return 0;
//     return (uint32_t)ctx->line_h;
// }
//
// static void set_tint(gs_effect_t *e, uint32_t rgba) {
//     vec4 v;
//     obs_rgba_to_vec4(&v, rgba);
//     gs_eparam_t *p = gs_effect_get_param_by_name(e, "tint");
//     if (p)
//         gs_effect_set_vec4(p, &v);
// }
//
// static void atlas_text_render(void *data, gs_effect_t *unused) {
//     (void)unused;
//     struct atlas_text_source *ctx = data;
//     if (!ctx || !ctx->atlas || !ctx->effect || !ctx->text)
//         return;
//
//     gs_effect_t *e = ctx->effect;
//
//     gs_eparam_t *image = gs_effect_get_param_by_name(e, "image");
//     if (!image)
//         return;
//     gs_effect_set_texture(image, ctx->atlas);
//     set_tint(e, ctx->color);
//
//     // Extremely minimal: draw each glyph as a sprite from the atlas.
//     // Real implementation would set texture coords per glyph; OBS/gs provides
//     // sprite drawing but sub-rect draws typically require custom vertex data.
//     //
//     // Here we illustrate the loop; youâ€™d replace the draw call with a quad
//     // using per-glyph UVs computed from (x,y,w,h)/(atlas_w,atlas_h).
//     int pen_x = 0;
//     int pen_y = 0;
//
//     while (gs_effect_loop(e, "Draw")) {
//         for (const char *p = ctx->text; *p; ++p) {
//             // Lookup glyph metrics for *p, compute UVs, then draw a quad at (pen_x, pen_y).
//             // pen_x += glyph.xadv;
//             (void)pen_y;
//             pen_x += 32; // placeholder advance
//         }
//     }
// }
